// <auto-generated/>
#nullable restore

using System.Collections.Generic;
using System.Threading.Tasks;

namespace TestLibrary;

internal class Orchestrator
{
    private readonly TestLibrary.A a;
    private readonly TestLibrary.B b;
    private readonly TestLibrary.C c;
    private readonly TestLibrary.D d;
    private readonly TestLibrary.E e;
    private readonly TestLibrary.F f;

    public Orchestrator(TestLibrary.A a, TestLibrary.B b, TestLibrary.C c, TestLibrary.D d, TestLibrary.E e, TestLibrary.F f)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
    }

    public async Task<int> Execute()
    {
        var resultATask = a.CallA();
        var resultBTask = b.CallB();
        var resultCTask = new System.Threading.Tasks.Task<int>(() => default);
        var resultDTask = d.CallD();
        var resultETask = new System.Threading.Tasks.Task<int>(() => default);

        var tasksToProcess = new List<Task> { resultATask, resultBTask, resultDTask };

        await foreach (var completed in Task.WhenEach(tasksToProcess))
        {
            if (!resultCTask.IsCompleted && resultATask.IsCompleted && resultBTask.IsCompleted)
            {
                resultCTask = c.CallC(resultATask.Result, resultBTask.Result);
                tasksToProcess.Add(resultCTask);
            }

            if (!resultETask.IsCompleted && resultDTask.IsCompleted)
            {
                resultETask = e.CallE(resultDTask.Result);
                tasksToProcess.Add(resultETask);
            }
        }

        var finalResult = await f.CallF(resultCTask.Result, resultETask.Result);

        return finalResult;
    }
}
