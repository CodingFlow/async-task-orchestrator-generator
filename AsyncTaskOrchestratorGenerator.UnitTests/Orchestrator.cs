// <auto-generated/>
#nullable restore

using System.Collections.Generic;
using System.Threading.Tasks;

namespace TestLibrary;

internal class Orchestrator
{
    private readonly TestLibrary.One one;
    private readonly TestLibrary.Two two;
    private readonly TestLibrary.Three three;
    private readonly TestLibrary.Four four;
    private readonly TestLibrary.Final final;

    public Orchestrator(TestLibrary.One one, TestLibrary.Two two, TestLibrary.Three three, TestLibrary.Four four, TestLibrary.Final final)
    {
        this.one = one;
        this.two = two;
        this.three = three;
        this.four = four;
        this.final = final;
    }

    public async Task<int> Execute()
    {
        var resultOneTask = one.FuncOne();
        var resultTwoTask = two.FuncTwo();
        var resultThreeTask = new System.Threading.Tasks.Task<int>(() => default);
        var resultFourTask = four.FuncFour();

        var tasksToProcess = new List<Task> { resultOneTask, resultTwoTask, resultFourTask };

        await foreach (var completed in Task.WhenEach(tasksToProcess))
        {
            if (!resultThreeTask.IsCompleted && resultOneTask.IsCompleted && resultTwoTask.IsCompleted)
            {
                resultThreeTask = three.FuncThree(resultOneTask.Result, resultTwoTask.Result);
                tasksToProcess.Add(resultThreeTask);
            }
        }

        var finalResult = await final.FuncFinal(resultThreeTask.Result, resultFourTask.Result);

        return finalResult;
    }
}
