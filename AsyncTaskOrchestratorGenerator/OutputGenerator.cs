using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AsyncTaskOrchestratorGenerator
{
    internal static class OutputGenerator
    {
        public static (string source, string className) GenerateClassOutputs(INamedTypeSymbol type) {
            var constructorArguments = GetAttributeConstructorArguments(type);
            var className = constructorArguments.First().Value.ToString();
            var executeMethodName = constructorArguments.ElementAt(1).Value.ToString();
            var interfaceName = $"I{className}";

            var accessModifier = type.DeclaredAccessibility.ToString().ToLower();
            var typeMembers = type.GetMembers();
            var fields = typeMembers.Where(m => m.Kind == SymbolKind.Field).Select(f => f as IFieldSymbol);
            var formattedFields = FormatFields(fields, typeMembers);
            var formattedConstructor = FormatConstructor(type, className, typeMembers);
            var (executeMethodSignatureData, executeMethodData, finalTaskData) = CreateExecuteMethodData(type, fields, executeMethodName);
            var formattedExecuteMethod = FormatExecuteMethod(executeMethodSignatureData, executeMethodData, finalTaskData);

            var parameterType = type.Constructors.First().Parameters.First().Type;
            var memberName = parameterType.GetMembers().First().Name;

            var source =
$@"// <auto-generated/>
#nullable restore

using System.Collections.Generic;
using System.Threading.Tasks;

namespace {type.ContainingNamespace.ToDisplayString()};

{accessModifier} class {className} : {interfaceName}
{{
{string.Join(@"
", formattedFields)}

    {formattedConstructor}

    {formattedExecuteMethod}
}}
";

            return (source, className);
        }

        public static (string source, string interfaceName) GenerateInterfaceOutputs(INamedTypeSymbol type) {
            var constructorArguments = GetAttributeConstructorArguments(type);
            var className = constructorArguments.First().Value.ToString();
            var executeMethodName = constructorArguments.ElementAt(1).Value.ToString();
            var interfaceName = $"I{className}";
            
            var accessModifier = type.DeclaredAccessibility.ToString().ToLower();
            var executeMethod = GetExecuteMethod(type);
            var executeMethodAccessibility = executeMethod.DeclaredAccessibility.ToString().ToLower();
            var formattedExecuteMethod = $"{executeMethodAccessibility} {executeMethod.ReturnType} {executeMethodName}();";

            var source =
$@"// <auto-generated/>
#nullable restore

namespace {type.ContainingNamespace.ToDisplayString()};

{accessModifier} interface {interfaceName}
{{
    {formattedExecuteMethod}
}}
";
            return (source, interfaceName);
        }

        private static System.Collections.Immutable.ImmutableArray<TypedConstant> GetAttributeConstructorArguments(INamedTypeSymbol type) {
            return type.GetAttributes().First((a) => a.AttributeClass.Name == nameof(AsyncTaskOrchestratorAttribute)).ConstructorArguments;
        }

        private static (ExecuteMethodSignatureData, Dictionary<string, TaskData>, TaskData) CreateExecuteMethodData(INamedTypeSymbol type, IEnumerable<IFieldSymbol> fields, string executeMethodName) {
            var executeMethod = GetExecuteMethod(type);
            var statements = (executeMethod.DeclaringSyntaxReferences.First().GetSyntax() as MethodDeclarationSyntax).Body.Statements;
            var variableStatements = statements.Remove(statements.Last());

            var variableData = variableStatements
                .Select(s => s as LocalDeclarationStatementSyntax)
                .SelectMany(v => v.Declaration.Variables)
                .Select(declarationSyntax => {
                    var invocation = declarationSyntax.Initializer.Value as InvocationExpressionSyntax;
                    var methodAccessExpression = invocation.Expression as MemberAccessExpressionSyntax;
                    var methodCallTypeName = methodAccessExpression.ToString().Split('.').First();
                    var methodCallType = fields.First(f => f.Name == methodCallTypeName).Type;
                    var methodCallName = methodAccessExpression.ToString().Split('.').Last();
                    var methodSymbol = methodCallType.GetMembers(methodCallName).First() as IMethodSymbol;

                    var arguments = invocation.ArgumentList.Arguments;
                    var argumentTypeNames = arguments.Select(a => a.ToString().Split('.').First());

                    return new TaskData
                    {
                        OutputName = declarationSyntax.Identifier.Text,
                        MethodCallName = methodAccessExpression.ToString(),
                        MethodCallReturnType = methodSymbol.ReturnType.ToString(),
                        DependenciesOutputNames = argumentTypeNames,
                        TaskName = $"{declarationSyntax.Identifier.Text}Task"
                    };
                });

            var lastStatement = statements.Last() as ReturnStatementSyntax;
            var invocation = lastStatement.Expression as InvocationExpressionSyntax;
            var methodAccessExpression = invocation.Expression as MemberAccessExpressionSyntax;
            var methodCallTypeName = methodAccessExpression.ToString().Split('.').First();
            var methodCallType = fields.First(f => f.Name == methodCallTypeName).Type;
            var methodCallName = methodAccessExpression.ToString().Split('.').Last();
            var methodSymbol = methodCallType.GetMembers(methodCallName).First() as IMethodSymbol;

            var arguments = invocation.ArgumentList.Arguments;
            var argumentTypeNames = arguments.Select(a => a.ToString().Split('.').First());

            var finalTaskData = new TaskData
            {
                OutputName = string.Empty,
                MethodCallName = methodAccessExpression.ToString(),
                MethodCallReturnType = methodSymbol.ReturnType.ToString(),
                DependenciesOutputNames = argumentTypeNames,
                TaskName = $"{methodCallTypeName}Task"
            };

            return (new ExecuteMethodSignatureData
            {
                AccessModifier = executeMethod.DeclaredAccessibility.ToString().ToLower(),
                ReturnType = executeMethod.ReturnType.ToString(),
                Name = executeMethodName,
            }, variableData.ToDictionary(taskData => taskData.OutputName), finalTaskData);
        }

        private static IMethodSymbol GetExecuteMethod(INamedTypeSymbol type) {
            return type
                            .GetMembers()
                            .Where(m => m is IMethodSymbol)
                            .First(m => (m as IMethodSymbol).MethodKind == MethodKind.Ordinary) as IMethodSymbol;
        }

        private static string FormatExecuteMethod(ExecuteMethodSignatureData signatureData, Dictionary<string, TaskData> data, TaskData finalTaskData) {
            var formattedTaskDeclarations = data.Select(keyValue => {
                var item = keyValue.Value;
                var hasDependencies = item.DependenciesOutputNames.Any();
                return hasDependencies ? 
                $@"var {item.TaskName} = new {item.MethodCallReturnType}(() => default);":
                $@"var {item.TaskName} = {item.MethodCallName}();";
            });

            var taskNames = data.Where(keyValue => !keyValue.Value.DependenciesOutputNames.Any()).Select(keyValue => keyValue.Value.TaskName);
            var formattedTasksList = $@"var tasksToProcess = new List<Task> {{ {string.Join(@", ", taskNames)} }};";

            var formattedHandleTaskCompletions = data.Where(keyValue => keyValue.Value.DependenciesOutputNames.Any()).Select(keyValue => {
                var item = keyValue.Value;
                var dependencyTaskNames = item.DependenciesOutputNames.Select(depName => data[depName].TaskName);
                var formattedCompletedDependencyTaskNames = string.Join(" && ", dependencyTaskNames.Select(tn => $"{tn}.IsCompleted"));
                var formattedResultDependencyTaskNames = string.Join(", ", dependencyTaskNames.Select(tn => $"{tn}.Result"));
                var formattedCallDependencies = $@"{item.TaskName} = {item.MethodCallName}({formattedResultDependencyTaskNames});";
                var formattedAddTaskToList = $@"tasksToProcess.Add({item.TaskName});";

                return $@"if (!{item.TaskName}.IsCompleted && {formattedCompletedDependencyTaskNames})
            {{
                {formattedCallDependencies}
                {formattedAddTaskToList}
            }}";
            });

            var formattedWhenEach = $@"await foreach (var completed in Task.WhenEach(tasksToProcess))
        {{
            { string.Join(@"

            ", formattedHandleTaskCompletions)}
        }}";

            var dependencyTaskName = finalTaskData.DependenciesOutputNames.Select(depName => data[depName].TaskName);
            var formattedResultDependencyTaskNames = string.Join(", ", dependencyTaskName.Select(tn => $"{tn}.Result"));
            var formattedFinalResult = $@"var finalResult = await {finalTaskData.MethodCallName}({formattedResultDependencyTaskNames});

        return finalResult;";
            
            return $@"{signatureData.AccessModifier} async {signatureData.ReturnType} {signatureData.Name}()
    {{
        {string.Join(@"
        ", formattedTaskDeclarations) }

        {formattedTasksList}

        {formattedWhenEach}

        {formattedFinalResult}
    }}";
        }

        private static string FormatConstructor(INamedTypeSymbol type, string className, IEnumerable<ISymbol> typeMembers) {
            var constructor = typeMembers
                .Where(m => m.Kind == SymbolKind.Method)
                .Select(m => m as IMethodSymbol)
                .First(m => m.MethodKind == MethodKind.Constructor);
            var constructorAccessModifier = constructor.DeclaredAccessibility.ToString().ToLower();
            var constructorParameters = constructor.Parameters.Select(p => $@"{p.Type} {p.Name}");
            var formattedParameters = string.Join(", ", constructorParameters);
            var constructorSyntax = constructor.DeclaringSyntaxReferences.First().GetSyntax() as ConstructorDeclarationSyntax;
            var statements = constructorSyntax.Body.Statements;
            var displayVariables = statements.Select(s => s.ToFullString().Trim());

            return $@"{constructorAccessModifier} {className}({formattedParameters})
    {{
        { string.Join(@"
        ", displayVariables)}
    }}";
        }

        private static IEnumerable<string> FormatFields(IEnumerable<IFieldSymbol> fields, IEnumerable<ISymbol> typeMembers) {
            var formattedFields = fields.Select(field => {
                var fieldAccessModifier = field.DeclaredAccessibility.ToString().ToLower();
                var fieldName = field.Name;

                return $@"    {fieldAccessModifier} readonly {field.Type} {fieldName};";
            });

            return formattedFields;
        }
    }
}